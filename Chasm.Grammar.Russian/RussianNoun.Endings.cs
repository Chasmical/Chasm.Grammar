using System;

namespace Chasm.Grammar.Russian
{
    public sealed partial class RussianNoun
    {
        private static string FindNounEnding(RussianNounDeclension declension, RussianNounInfo info)
        {
            const RussianDeclensionFlags allCircledNumbers
                = RussianDeclensionFlags.CircledOne |
                  RussianDeclensionFlags.CircledTwo |
                  RussianDeclensionFlags.CircledThree;

            // Handle ①②③ marks
            if ((declension.Flags & allCircledNumbers) != 0)
            {
                string? res = GetCircledNumberOverrideEnding(declension, info);
                if (res is not null) return res;
            }

            ReadOnlySpan<byte> lookup = NounEndingLookup;

            // Get indices of both unaccented and accented forms of endings (usually they're the same)
            int index = ComposeEndingIndex(declension, info, info.Case);
            int unAcIndex = lookup[index];

            // Accusative case usually uses either genitive's or nominative's ending, depending on animacy.
            // In such case, the lookup yields the index 0 (element = null). Don't confuse with "" ('null ending' in grammar).
            if (unAcIndex == 0)
            {
                index = ComposeEndingIndex(declension, info, info.IsAnimate ? RussianCase.Genitive : RussianCase.Nominative);
                unAcIndex = lookup[index];
            }
            // Accented ending index is right next to the unaccented one's
            int acIndex = lookup[index + 1];

            // If the ending depends on the accent, determine the one needed here.
            // If the endings are the same, it doesn't matter which one is used.
            bool accented = unAcIndex != acIndex && IsAccentOnEnding(declension, info);

            return NounEndingArray[accented ? acIndex : unAcIndex];
        }

        private static string? GetCircledNumberOverrideEnding(RussianNounDeclension declension, RussianNounInfo info)
        {
            if (info.IsPlural)
            {
                if (
                    (declension.Flags & RussianDeclensionFlags.CircledOne) != 0 &&
                    (info.Case == RussianCase.Nominative || info.Case == RussianCase.Accusative && !info.IsAnimate)
                )
                {
                    int decl = declension.Digit;
                    switch (info.Gender)
                    {
                        case RussianGender.Neuter:
                            return decl is 1 or 5 or 8 ? "ы" : "и";
                        case RussianGender.Masculine:
                            return decl is 1 or 3 or 4 or 5 ? "а" : "я";
                        case RussianGender.Feminine:
                            throw new InvalidOperationException();
                    }
                }
                if (
                    (declension.Flags & RussianDeclensionFlags.CircledTwo) != 0 &&
                    (info.Case == RussianCase.Genitive || info.Case == RussianCase.Accusative && info.IsAnimate)
                )
                {
                    int decl = declension.Digit;
                    switch (info.Gender)
                    {
                        case RussianGender.Neuter:
                            return decl switch
                            {
                                1 or 3 or 8 => "ов",
                                4 or 5 when IsAccentOnEnding(declension, info) => "ов",
                                2 or 6 or 7 when IsAccentOnEnding(declension, info) => "ёв",
                                _ => "ев",
                            };
                        case RussianGender.Masculine:
                            return decl is 1 or 3 or 4 or 5 ? "" : "ь";
                        case RussianGender.Feminine:
                            return "ей";
                    }
                }
            }
            else // if (info.IsSingular)
            {
                if ((declension.Flags & RussianDeclensionFlags.CircledThree) != 0 && declension.Digit == 7)
                {
                    if (info.Case == RussianCase.Prepositional || info.Gender == RussianGender.Feminine && info.Case == RussianCase.Dative)
                        return "е";
                }
            }
            return null;
        }

        private static bool IsAccentOnEnding(RussianNounDeclension declension, RussianNounInfo info)
        {
            bool plural = info.IsPlural;

            // Accusative case's endings and accents depend on the noun's animacy.
            // Some accents, though, depend on the original case, like D′ and F′.
            RussianCase normCase = info.Case;
            if (normCase == RussianCase.Accusative)
                normCase = info.IsAnimate ? RussianCase.Genitive : RussianCase.Nominative;

            return declension.Letter switch
            {
                RussianDeclensionAccent.A => false,
                RussianDeclensionAccent.B => true,
                RussianDeclensionAccent.C => plural,
                RussianDeclensionAccent.D => !plural,
                RussianDeclensionAccent.E => plural && normCase != RussianCase.Nominative,
                RussianDeclensionAccent.F => !plural || normCase != RussianCase.Nominative,
                RussianDeclensionAccent.Bp => plural || normCase != RussianCase.Instrumental,
                RussianDeclensionAccent.Dp => !plural && info.Case != RussianCase.Accusative,
                RussianDeclensionAccent.Fp => plural ? normCase != RussianCase.Nominative : info.Case != RussianCase.Accusative,
                RussianDeclensionAccent.Fpp => plural ? normCase != RussianCase.Nominative : normCase != RussianCase.Instrumental,
            };
        }

        private static int ComposeEndingIndex(RussianNounDeclension declension, RussianNounInfo info, RussianCase @case)
        {
            // Context-dependent variables are more significant and come first, noun-dependent variables come next,
            // And finally, unaccented and accented forms are next to each other to make accent-checking simpler.

            // Composite index: [case:6] [plural:2] [gender:3] [declension:8] [accent:2]

            int index = (int)@case;
            index = index * 2 + (info.IsPlural ? 1 : 0);
            index = index * 3 + (int)info.Gender;
            index = index * 8 + (declension.Digit - 1);
            index *= 2; // accent takes up the least significant bit

            return index;
        }

        // A compact (576 B) noun ending index lookup, used by GetNounEndingIndices()
        private static ReadOnlySpan<byte> NounEndingLookup =>
        [
            0x14, 0x14, 0x01, 0x18, 0x14, 0x14, 0x01, 0x14, 0x01, 0x14, 0x01, 0x18, 0x01, 0x18, 0x14, 0x14,
            0x08, 0x08, 0x13, 0x13, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x10, 0x10, 0x10, 0x10, 0x13, 0x13,
            0x03, 0x03, 0x09, 0x09, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x09, 0x09, 0x09, 0x09, 0x13, 0x13,
            0x03, 0x03, 0x09, 0x09, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x09, 0x09, 0x09, 0x09, 0x03, 0x03,
            0x11, 0x11, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x11, 0x11, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
            0x11, 0x11, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x11, 0x11, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
            0x03, 0x03, 0x09, 0x09, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x09, 0x09, 0x09, 0x09, 0x03, 0x03,
            0x03, 0x03, 0x09, 0x09, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x09, 0x09, 0x09, 0x09, 0x02, 0x02,
            0x11, 0x11, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x11, 0x11, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
            0x08, 0x08, 0x13, 0x0e, 0x08, 0x08, 0x08, 0x0e, 0x08, 0x08, 0x10, 0x10, 0x10, 0x10, 0x08, 0x08,
            0x17, 0x17, 0x0e, 0x0e, 0x17, 0x17, 0x0e, 0x0e, 0x19, 0x17, 0x19, 0x1b, 0x19, 0x1b, 0x0e, 0x0e,
            0x08, 0x08, 0x13, 0x0e, 0x08, 0x08, 0x08, 0x0e, 0x08, 0x08, 0x10, 0x10, 0x10, 0x10, 0x0e, 0x0e,
            0x04, 0x04, 0x0d, 0x0d, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0d, 0x0d, 0x0d, 0x0d, 0x04, 0x04,
            0x04, 0x04, 0x0d, 0x0d, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0d, 0x0d, 0x0d, 0x0d, 0x02, 0x02,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02,
            0x05, 0x05, 0x0a, 0x0a, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x0a, 0x0a, 0x0a, 0x0a, 0x05, 0x05,
            0x05, 0x05, 0x0a, 0x0a, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
            0x05, 0x05, 0x0a, 0x0a, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x04, 0x04, 0x0d, 0x0d, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0d, 0x0d, 0x0d, 0x0d, 0x13, 0x13,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x0f, 0x0f, 0x12, 0x15, 0x0f, 0x0f, 0x12, 0x0f, 0x12, 0x0f, 0x12, 0x15, 0x12, 0x15, 0x0f, 0x0f,
            0x0f, 0x0f, 0x12, 0x15, 0x0f, 0x0f, 0x12, 0x0f, 0x12, 0x0f, 0x12, 0x15, 0x12, 0x15, 0x12, 0x15,
            0x16, 0x16, 0x0e, 0x1a, 0x16, 0x16, 0x0e, 0x16, 0x0e, 0x16, 0x0e, 0x1a, 0x0e, 0x1a, 0x1c, 0x1c,
            0x06, 0x06, 0x0b, 0x0b, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x0b, 0x0b, 0x0b, 0x0b, 0x06, 0x06,
            0x06, 0x06, 0x0b, 0x0b, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
            0x06, 0x06, 0x0b, 0x0b, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02,
            0x07, 0x07, 0x0c, 0x0c, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x0c, 0x0c, 0x0c, 0x0c, 0x07, 0x07,
            0x07, 0x07, 0x0c, 0x0c, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
            0x07, 0x07, 0x0c, 0x0c, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
        ];
        // The 28 standard noun endings (and also null, or index 0, means animacy-dependent accusative case)
        private static readonly string[] NounEndingArray =
        [
            null!, "е", "и", "а", "у", "ам", "ами", "ах", "", "я", "ям", "ями", "ях", "ю", "ей",
            "ом", "й", "ы", "ем", "ь", "о", "ём", "ой", "ов", "ё", "ев", "ёй", "ёв", "ью",
        ];

    }
}
